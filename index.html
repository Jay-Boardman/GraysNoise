
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="theme-color" content="#0f172a" />
    <title>Grays Noise</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- React & Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: 'Rajdhani', sans-serif;
        background-color: #0f172a;
        color: #e2e8f0;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        overscroll-behavior-y: none;
      }
      h1, h2, h3, .brand-font {
        font-family: 'Orbitron', sans-serif;
      }
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #0f172a; }
      ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
      .glass-panel {
        background: rgba(15, 23, 42, 0.6);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(148, 163, 184, 0.1);
      }
      .no-select { user-select: none; -webkit-user-select: none; }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/",
    "react/": "https://aistudiocdn.com/react@^19.2.1/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // --- IndexedDB Logic ---
      const DB_NAME = 'GraysNoiseDB';
      const DB_VERSION = 5; // Bumped version to force clean slate with new schema
      const STORE_NAME = 'custom_sounds';

      const initDB = () => {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (db.objectStoreNames.contains(STORE_NAME)) {
               db.deleteObjectStore(STORE_NAME);
            }
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          };
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      };

      const saveSoundToDB = async (soundObj) => {
        try {
          const db = await initDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            
            // Create a clean object to store
            // IMPORTANT: We store the mimeType explicitly to help iOS reconstruct it later
            const record = {
              id: soundObj.id,
              name: soundObj.name,
              type: soundObj.type,
              color: soundObj.color,
              blob: soundObj.blob,
              mimeType: soundObj.blob.type || 'audio/mp4' // Fallback
            };
            
            store.put(record);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        } catch (e) {
          console.error("DB Save Error", e);
        }
      };

      const getSoundsFromDB = async () => {
        try {
          const db = await initDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const request = store.getAll();
            request.onsuccess = () => {
               const records = request.result || [];
               // Rehydrate: Convert stored Blobs back into playable URLs
               const sounds = records.map(rec => {
                  if (rec.blob instanceof Blob) {
                     // iOS Fix: Explicitly recreate Blob with the correct MIME type
                     // This prevents the browser from treating it as generic binary data
                     const safeBlob = new Blob([rec.blob], { type: rec.mimeType || 'audio/mp4' });
                     return { 
                       ...rec, 
                       url: URL.createObjectURL(safeBlob) 
                     };
                  }
                  return rec;
               });
               resolve(sounds);
            };
            request.onerror = () => reject(request.error);
          });
        } catch (e) {
          console.error("DB Load Error", e);
          return [];
        }
      };

      const deleteSoundFromDB = async (id) => {
        try {
          const db = await initDB();
          const tx = db.transaction(STORE_NAME, 'readwrite');
          tx.objectStore(STORE_NAME).delete(id);
          return new Promise(resolve => {
             tx.oncomplete = () => resolve();
          });
        } catch (e) {
          console.error("DB Delete Error", e);
        }
      };

      const updateSoundNameInDB = async (id, newName) => {
        try {
          const db = await initDB();
          const tx = db.transaction(STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORE_NAME);
          const getReq = store.get(id);
          getReq.onsuccess = () => {
             if (getReq.result) {
                const data = getReq.result;
                data.name = newName;
                store.put(data);
             }
          };
        } catch (e) {}
      };

      // --- Constants ---
      const SoundType = { PRELOADED: 'PRELOADED', RECORDED: 'RECORDED', UPLOADED: 'UPLOADED' };

      const PRELOADED_SOUNDS = [
        { id: 's1', name: 'Vine Boom', url: 'https://www.myinstants.com/media/sounds/vine-boom.mp3', type: SoundType.PRELOADED, color: 'cyan' },
        { id: 's2', name: 'Airhorn', url: 'https://www.myinstants.com/media/sounds/air-horn-club-sample_1.mp3', type: SoundType.PRELOADED, color: 'fuchsia' },
        { id: 's3', name: 'Anime Wow', url: 'https://www.myinstants.com/media/sounds/anime-wow-sound-effect.mp3', type: SoundType.PRELOADED, color: 'lime' },
        { id: 's4', name: 'Whip Crack', url: 'https://www.myinstants.com/media/sounds/whipped.mp3', type: SoundType.PRELOADED, color: 'blue' },
        { id: 's5', name: 'Cartoon Boing', url: 'https://www.myinstants.com/media/sounds/boing.mp3', type: SoundType.PRELOADED, color: 'violet' },
        { id: 's6', name: 'Spongebob', url: 'https://www.myinstants.com/media/sounds/spongebob-fail.mp3', type: SoundType.PRELOADED, color: 'rose' },
        { id: 's7', name: 'Roblox Oof', url: 'https://www.myinstants.com/media/sounds/roblox-death-sound_1.mp3', type: SoundType.PRELOADED, color: 'red' },
        { id: 's8', name: 'Wet Fart', url: 'https://www.myinstants.com/media/sounds/wet-fart_1.mp3', type: SoundType.PRELOADED, color: 'teal' },
        { id: 's9', name: 'Cricket', url: 'https://www.myinstants.com/media/sounds/cricket.mp3', type: SoundType.PRELOADED, color: 'amber' },
        { id: 's10', name: 'Victory', url: 'https://www.myinstants.com/media/sounds/tada.mp3', type: SoundType.PRELOADED, color: 'emerald' }
      ];

      // --- SoundButton Component ---
      const SoundButton = ({ sound, stopSignal, onDelete, onRename }) => {
        const [active, setActive] = useState(false);
        const [error, setError] = useState(false);
        const [progress, setProgress] = useState(0);
        const [isEditing, setIsEditing] = useState(false);
        const [editName, setEditName] = useState(sound.name);
        
        const audioRef = useRef(null);
        const inputRef = useRef(null);

        // Global Stop
        useEffect(() => {
          if (stopSignal > 0 && audioRef.current) {
            audioRef.current.pause();
            audioRef.current.currentTime = 0;
            setActive(false);
            setProgress(0);
          }
        }, [stopSignal]);

        // Play Logic
        const playSound = async () => {
          if (error || isEditing) return;

          // cleanup previous
          if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current = null;
          }

          try {
            // New Audio instance every time for reliability on iOS
            const audio = new Audio(sound.url);
            audioRef.current = audio;
            
            // Critical for iOS Safari:
            // Explicitly load() to tell the browser this is a new intentional interaction
            audio.load();

            audio.onplay = () => { setActive(true); setError(false); };
            audio.onended = () => { setActive(false); setProgress(0); };
            audio.ontimeupdate = () => {
              if (audio.duration) setProgress((audio.currentTime / audio.duration) * 100);
            };
            audio.onerror = (e) => {
              console.error("Audio Error:", e, sound.url);
              setError(true);
              setActive(false);
            };

            await audio.play();
          } catch (e) {
            console.error("Playback failed", e);
            // Sometimes it's just an AbortError from rapid clicking, which is safe to ignore
          }
        };

        const handleSaveRename = (e) => {
          if(e) e.stopPropagation();
          if (onRename && editName.trim()) {
              onRename(sound.id, editName.trim());
              setIsEditing(false);
          } else {
              setEditName(sound.name);
              setIsEditing(false);
          }
        };

        const getColors = (c) => {
           const map = {
            cyan: 'border-cyan-500 shadow-cyan-500/50 hover:bg-cyan-500/10 text-cyan-400',
            fuchsia: 'border-fuchsia-500 shadow-fuchsia-500/50 hover:bg-fuchsia-500/10 text-fuchsia-400',
            lime: 'border-lime-500 shadow-lime-500/50 hover:bg-lime-500/10 text-lime-400',
            blue: 'border-blue-500 shadow-blue-500/50 hover:bg-blue-500/10 text-blue-400',
            violet: 'border-violet-500 shadow-violet-500/50 hover:bg-violet-500/10 text-violet-400',
            rose: 'border-rose-500 shadow-rose-500/50 hover:bg-rose-500/10 text-rose-400',
            red: 'border-red-500 shadow-red-500/50 hover:bg-red-500/10 text-red-400',
            teal: 'border-teal-500 shadow-teal-500/50 hover:bg-teal-500/10 text-teal-400',
            amber: 'border-amber-500 shadow-amber-500/50 hover:bg-amber-500/10 text-amber-400',
            emerald: 'border-emerald-500 shadow-emerald-500/50 hover:bg-emerald-500/10 text-emerald-400',
           };
           return map[c] || map['cyan'];
        };

        const themeClass = error ? 'border-red-900/50 text-red-700 bg-red-900/10' : getColors(sound.color);

        return (
          <div className="relative group no-select">
            <button
              onClick={playSound}
              disabled={error}
              className={`
                relative w-full aspect-square flex flex-col items-center justify-center p-4
                border-2 rounded-xl transition-all duration-200 ease-out
                bg-slate-900/40 backdrop-blur-sm z-10
                ${themeClass}
                ${active ? 'scale-95 shadow-[0_0_30px_rgba(0,0,0,0.5)] bg-opacity-20' : (!error && 'hover:-translate-y-1 hover:shadow-lg')}
              `}
            >
              {active && (
                 <div className="absolute bottom-0 left-0 h-1 bg-current opacity-70 transition-all duration-100" style={{ width: `${progress}%` }} />
              )}

              <div className={`text-3xl mb-2 transition-transform duration-200 ${active ? 'scale-110' : ''}`}>
                 {error ? (
                   <svg className="w-8 h-8 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" /></svg>
                 ) : (
                   <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" /></svg>
                 )}
              </div>
              
              {isEditing ? (
                 <input 
                    ref={inputRef} type="text" value={editName}
                    onChange={(e) => setEditName(e.target.value)}
                    onKeyDown={(e) => { if(e.key==='Enter') handleSaveRename(); if(e.key==='Escape') setIsEditing(false); e.stopPropagation(); }}
                    onClick={(e) => e.stopPropagation()}
                    onBlur={() => handleSaveRename()}
                    className="w-full text-xs sm:text-sm font-medium text-center bg-slate-950/80 text-white rounded px-1 py-0.5 outline-none border border-cyan-500 z-30 shadow-lg"
                    autoFocus
                 />
              ) : (
                <span className="text-xs sm:text-sm font-medium tracking-wider uppercase truncate max-w-full brand-font">
                  {error ? 'Unavailable' : sound.name}
                </span>
              )}
            </button>

            {/* EDIT & DELETE BUTTONS - Outside the main button click area */}
            {(onDelete || onRename) && !isEditing && (
              <div className="absolute top-2 right-2 flex gap-1 z-20">
                {onRename && (
                  <button 
                    type="button"
                    onClick={(e) => { e.stopPropagation(); setIsEditing(true); setEditName(sound.name); }}
                    className="p-1.5 bg-slate-900/80 hover:bg-slate-700 rounded-full cursor-pointer text-slate-400 hover:text-cyan-400 backdrop-blur-md transition-colors shadow-md border border-slate-700/50"
                  >
                    <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg>
                  </button>
                )}
                {onDelete && (
                  <button 
                    type="button"
                    onClick={(e) => { e.stopPropagation(); onDelete(sound.id); }}
                    className="p-2 bg-slate-900/80 hover:bg-red-500/20 rounded-full cursor-pointer text-slate-400 hover:text-red-400 backdrop-blur-md transition-colors shadow-md border border-slate-700/50"
                  >
                    <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></svg>
                  </button>
                )}
              </div>
            )}
          </div>
        );
      };

      // --- Recorder Component ---
      const Recorder = ({ onRecordingComplete }) => {
        const [isRecording, setIsRecording] = useState(false);
        const [time, setTime] = useState(0);
        const mediaRef = useRef(null);
        const chunksRef = useRef([]);
        const timerRef = useRef(null);

        const start = async () => {
          if (!navigator.mediaDevices) return alert("Mic not supported");
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            // iOS COMPATIBILITY: Prefer mp4/aac. WebM often fails to play back on iOS from Blobs.
            let mime = 'audio/webm';
            if (MediaRecorder.isTypeSupported('audio/mp4')) mime = 'audio/mp4';
            else if (MediaRecorder.isTypeSupported('audio/aac')) mime = 'audio/aac';
            
            const recorder = new MediaRecorder(stream, { mimeType: mime });
            mediaRef.current = recorder;
            chunksRef.current = [];

            recorder.ondataavailable = e => { if(e.data.size > 0) chunksRef.current.push(e.data); };
            
            recorder.onstop = () => {
              const type = recorder.mimeType || mime; 
              const blob = new Blob(chunksRef.current, { type });
              // Create temp URL
              const url = URL.createObjectURL(blob);
              const name = `Rec ${new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit',second:'2-digit'})}`;
              onRecordingComplete(url, name, blob);
              stream.getTracks().forEach(t => t.stop());
            };

            recorder.start();
            setIsRecording(true);
            setTime(0);
            timerRef.current = setInterval(() => setTime(t => t+1), 1000);
          } catch(e) {
            console.error(e);
            alert("Mic access denied");
          }
        };

        const stop = () => {
          if (mediaRef.current && isRecording) {
            mediaRef.current.stop();
            setIsRecording(false);
            clearInterval(timerRef.current);
          }
        };

        useEffect(() => () => clearInterval(timerRef.current), []);

        return (
          <button onClick={isRecording ? stop : start} className={`flex items-center gap-2 px-6 py-3 rounded-full font-bold uppercase transition-all ${isRecording ? 'bg-red-500/20 text-red-400 border border-red-500 shadow-[0_0_15px_rgba(239,68,68,0.4)] animate-pulse' : 'bg-slate-800 border border-slate-700 text-slate-300 hover:text-cyan-400 hover:border-cyan-400'}`}>
            {isRecording ? <><span className="w-2 h-2 rounded-full bg-red-500" /> STOP ({time}s)</> : <><svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z" /></svg> RECORD</>}
          </button>
        );
      };

      // --- Uploader Component ---
      const Uploader = ({ onUpload }) => {
        const inputRef = useRef(null);
        const handleChange = (e) => {
          const file = e.target.files?.[0];
          if (file) {
            const url = URL.createObjectURL(file);
            const name = file.name.replace(/\.[^/.]+$/, "").substring(0, 12);
            onUpload(url, name, file);
            if (inputRef.current) inputRef.current.value = '';
          }
        };
        return (
          <>
            <input type="file" ref={inputRef} onChange={handleChange} accept="audio/*" className="hidden" />
            <button onClick={() => inputRef.current?.click()} className="flex items-center gap-2 px-6 py-3 rounded-full font-bold uppercase bg-slate-800 border border-slate-700 text-slate-300 hover:text-fuchsia-400 hover:border-fuchsia-400 transition-all">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" /></svg>
              UPLOAD
            </button>
          </>
        );
      };

      // --- App Component ---
      const App = () => {
        const [sounds, setSounds] = useState(PRELOADED_SOUNDS);
        const [stopSignal, setStopSignal] = useState(0);

        // Initial Load
        useEffect(() => {
          getSoundsFromDB().then(custom => {
            setSounds([...PRELOADED_SOUNDS, ...custom]);
          });
        }, []);

        const handleAdd = async (url, name, blob, type) => {
          const newSound = {
            id: `custom-${Date.now()}`,
            name: name || 'Custom',
            url,
            type,
            color: type === SoundType.RECORDED ? 'red' : 'blue',
            blob
          };
          
          await saveSoundToDB(newSound);
          setSounds(prev => [...prev, newSound]);
        };

        const handleDelete = async (id) => {
           await deleteSoundFromDB(id);
           setSounds(prev => {
             const found = prev.find(s => s.id === id);
             if (found && found.url && found.url.startsWith('blob:')) {
               URL.revokeObjectURL(found.url);
             }
             return prev.filter(s => s.id !== id);
           });
        };

        const handleRename = async (id, newName) => {
          await updateSoundNameInDB(id, newName);
          setSounds(prev => prev.map(s => s.id === id ? { ...s, name: newName } : s));
        };

        return (
          <div className="min-h-screen bg-slate-950 text-slate-200 overflow-x-hidden">
            {/* Background */}
            <div className="fixed inset-0 z-0 pointer-events-none">
              <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-cyan-500/5 rounded-full blur-[120px]"></div>
              <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-fuchsia-500/5 rounded-full blur-[120px]"></div>
            </div>

            <div className="relative z-10 max-w-6xl mx-auto px-4 py-8 flex flex-col min-h-screen">
              <header className="mb-10 text-center space-y-2">
                <h1 className="text-5xl md:text-7xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-white to-fuchsia-400 drop-shadow-[0_0_10px_rgba(34,211,238,0.5)]">
                  GRAYS NOISE
                </h1>
                <p className="text-slate-400 font-light tracking-[0.2em] text-sm md:text-base uppercase">Futuristic Audio Interface v1.0</p>
              </header>

              <main className="flex-grow pb-32">
                <div className="glass-panel rounded-2xl p-6 md:p-8 mb-8 shadow-2xl">
                   <div className="flex items-center justify-between mb-6">
                      <h2 className="text-xl font-bold text-slate-300 brand-font flex items-center gap-2">
                        <span className="w-2 h-2 bg-cyan-400 rounded-full animate-pulse"></span>
                        Sound Bank
                      </h2>
                      <span className="text-xs text-slate-500 uppercase tracking-widest">{sounds.length} Active Nodes</span>
                   </div>
                  
                  <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 md:gap-6">
                    {sounds.map(sound => (
                      <SoundButton 
                        key={sound.url || sound.id} /* FORCE RE-RENDER ON URL CHANGE */
                        sound={sound} 
                        stopSignal={stopSignal}
                        onDelete={sound.type !== SoundType.PRELOADED ? handleDelete : undefined} 
                        onRename={sound.type !== SoundType.PRELOADED ? handleRename : undefined}
                      />
                    ))}
                  </div>
                </div>
              </main>

              <footer className="fixed bottom-8 left-0 right-0 z-50 flex justify-center px-4 pointer-events-none">
                 <div className="glass-panel p-2 sm:p-3 rounded-full shadow-2xl flex items-center gap-2 sm:gap-4 pointer-events-auto bg-slate-900/95 backdrop-blur-xl">
                   <Recorder onRecordingComplete={(url, name, blob) => handleAdd(url, name, blob, SoundType.RECORDED)} />
                   <div className="w-px h-8 bg-slate-700/50 hidden sm:block"></div>
                   <button onClick={() => setStopSignal(Date.now())} className="flex items-center gap-2 px-4 sm:px-6 py-3 rounded-full font-bold uppercase bg-red-500/10 border border-red-500/50 text-red-400 hover:bg-red-500/20 whitespace-nowrap">
                     <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z" /></svg>
                     <span className="hidden sm:inline">Stop All</span>
                   </button>
                   <div className="w-px h-8 bg-slate-700/50 hidden sm:block"></div>
                   <Uploader onUpload={(url, name, blob) => handleAdd(url, name, blob, SoundType.UPLOADED)} />
                 </div>
              </footer>
              
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
